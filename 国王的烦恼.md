## 国王的烦恼
[题目链接][0]

[0]:http://lx.lanqiao.cn/problem.page?gpid=T114

把拆桥的过程逆过来考虑，这样可以用并查集来做。根据输入可以确定每个桥“搭建好”的日期，在那一天如果两个岛不连通，就把天数加一。需要注意如果同一天有多个桥需要搭建，天数只能增加一次。


```
#pragma warning (disable:4996)
#include <cstdio>
#include <queue>
#include <iostream>
using namespace std;
const int M = 1e5 + 5;
struct Edge
{
	int fr, to, t;
	bool operator < (const Edge &b) const
	{
		return t < b.t;
	}
};
priority_queue<Edge> qe; //建立一个堆控制遍历的顺序
int pre[M];
void Init(int n)
{
	for (int i = 1; i <= n; i++)
		pre[i] = i;
	return;
}
int Find(int x)
{
	int r = x;
	while (pre[r] != r)
		r = pre[r];
	int j;
	while (pre[x] != r)
	{
		j = pre[x];
		pre[x] = r;
		x = j;
	}
	return r;
}
void Join(int x, int y)
{
	int tx = Find(x);
	int ty = Find(y);
	//printf("tx, ty :%d %d\n", tx, ty);
	if (tx != ty)
		pre[ty] = tx;
	return;
}
bool check(int n)
{
	int cnt = 0;
	for (int i = 1; i <= n; i++)
	{
		if (pre[i] == i)
			++cnt;
		if (cnt > 1)
			return false;
	}
	return true;
}
void showpre(int n)     //此处不会调用，调试函数
{
	printf("pre: ");
	for (int i = 1; i <= n; i++)
		printf("%d ", pre[i]);
	printf("\n");
}
int main()
{
	int maxn = -1, days = 1;
	Edge tmp, pre_tmp;
	int n, m;
	scanf("%d%d", &n, &m);
	Init(n);
	for (int i = 0; i < m; i++)
	{
		scanf("%d%d%d", &tmp.fr, &tmp.to, &tmp.t);
		qe.push(tmp);
		maxn = max(maxn, tmp.t);
	}
	pre_tmp = qe.top();
	while (!qe.empty())
	{
		tmp = qe.top();
		qe.pop();
		int xt = Find(tmp.fr);
		int yt = Find(tmp.to);
		if (xt != yt)
		{
			pre[yt] = xt;
			if (tmp.t != pre_tmp.t)
			{
				days++;
				pre_tmp = tmp;
			}
		}
	}
	printf("%d", days);
	return 0;
}
```
